Public Sub DebugSingleQuery(strQueryName As String)

    Dim db              As DAO.Database
    Dim qdf             As DAO.QueryDef
    Dim strTargetTable  As String
    Dim arrTarget()     As String
    Dim arrSource()     As String
    Dim i               As Integer

    Set db = CurrentDb
    Set qdf = db.QueryDefs(strQueryName)

    Debug.Print "=== RAW SQL ==="
    Debug.Print qdf.SQL
    Debug.Print ""

    If ParseAppendSQL(qdf.SQL, strTargetTable, arrTarget, arrSource) Then
        Debug.Print "Target Table: " & strTargetTable
        Debug.Print "Field mappings:"
        For i = 0 To UBound(arrTarget)
            Debug.Print "  [" & arrSource(i) & "]  -->  [" & arrTarget(i) & "]"
        Next i
    Else
        Debug.Print "PARSE FAILED - check the RAW SQL above"
    End If

    Set db = Nothing

End Sub


'==============================================================================
' CheckAllAppendQueries
' Automatically finds ALL append queries in the database, parses their
' field mappings, checks source data against target field sizes, and logs
' any violations to tblFieldSizeLog.
'
' Call this once to audit the entire database before running any appends.
' Returns: Total violation count across all queries
'==============================================================================
Public Function CheckAllAppendQueries() As Long

    Dim db              As DAO.Database
    Dim qdf             As DAO.QueryDef
    Dim lngTotal        As Long
    Dim lngQueryHits    As Long
    Dim strLog          As String

    Set db = CurrentDb

    ' --- Wipe the log table fresh ---
    db.Execute "DELETE FROM tblFieldSizeLog", dbFailOnError

    lngTotal = 0

    ' --- Loop every query in the database ---
    For Each qdf In db.QueryDefs
        ' dbQAction = 128, but we parse SQL to confirm it's an INSERT INTO
        If qdf.Type = dbQAction Then
            If IsAppendQuery(qdf.SQL) Then
                lngQueryHits = CheckSingleAppendQuery(db, qdf)
                lngTotal = lngTotal + lngQueryHits
            End If
        End If
    Next qdf

    Set db = Nothing

    CheckAllAppendQueries = lngTotal

End Function


'==============================================================================
' IsAppendQuery
' Returns True if the SQL string is an INSERT INTO ... SELECT statement
'==============================================================================
Private Function IsAppendQuery(strSQL As String) As Boolean
    Dim strUpper As String
    strUpper = UCase(Trim(strSQL))
    IsAppendQuery = (Left(strUpper, 11) = "INSERT INTO")
End Function


'==============================================================================
' CheckSingleAppendQuery
' Parses one append query's SQL, extracts target table + field list,
' opens the source recordset, and checks each text field for size violations.
' Logs violations to tblFieldSizeLog.
'==============================================================================
Private Function CheckSingleAppendQuery( _
        db As DAO.Database, _
        qdf As DAO.QueryDef) As Long

    Dim strSQL          As String
    Dim strTargetTable  As String
    Dim arrTargetFields() As String
    Dim arrSourceFields() As String
    Dim rsSource        As DAO.Recordset
    Dim tdTarget        As DAO.TableDef
    Dim lngViolations   As Long
    Dim i               As Integer
    Dim strValue        As String
    Dim intMaxSize      As Integer
    Dim strKeyVal       As String

    On Error GoTo ErrHandler

    lngViolations = 0
    strSQL = qdf.SQL

    ' --- Parse the SQL to extract target table and field lists ---
    If Not ParseAppendSQL(strSQL, strTargetTable, arrTargetFields, arrSourceFields) Then
        Debug.Print "Could not parse query: " & qdf.Name
        CheckSingleAppendQuery = 0
        Exit Function
    End If

    ' --- Get target table definition ---
    On Error Resume Next
    Set tdTarget = db.TableDefs(strTargetTable)
    If Err.Number <> 0 Or tdTarget Is Nothing Then
        Debug.Print "Target table not found for query: " & qdf.Name & " -> " & strTargetTable
        Err.Clear
        On Error GoTo ErrHandler
        CheckSingleAppendQuery = 0
        Exit Function
    End If
    On Error GoTo ErrHandler

    ' --- Build the SELECT query to get source data ---
    ' Re-run just the SELECT portion of the append query
    Dim strSelectSQL    As String
    strSelectSQL = ExtractSelectPortion(strSQL, arrSourceFields)

    If strSelectSQL = "" Then
        Debug.Print "Could not extract SELECT portion for query: " & qdf.Name
        CheckSingleAppendQuery = 0
        Exit Function
    End If

    ' --- Open source recordset ---
    On Error Resume Next
    Set rsSource = db.OpenRecordset(strSelectSQL, dbOpenSnapshot)
    If Err.Number <> 0 Then
        Debug.Print "Could not open source recordset for query: " & qdf.Name & " - " & Err.Description
        Err.Clear
        On Error GoTo ErrHandler
        CheckSingleAppendQuery = 0
        Exit Function
    End If
    On Error GoTo ErrHandler

    If rsSource.EOF Then GoTo CleanUp

    ' --- Loop every source record ---
    Do While Not rsSource.EOF

        ' Try to grab first field as a row identifier for the log
        On Error Resume Next
        strKeyVal = Nz(rsSource.Fields(0).Value, "(null)")
        On Error GoTo ErrHandler

        ' --- Check each mapped field pair ---
        For i = 0 To UBound(arrTargetFields)

            ' Only care about text fields in the target
            On Error Resume Next
            Dim fldType As Integer
            fldType = tdTarget.Fields(arrTargetFields(i)).Type
            If Err.Number <> 0 Then
                Err.Clear
                On Error GoTo ErrHandler
                GoTo NextField
            End If
            On Error GoTo ErrHandler

            If fldType <> dbText Then GoTo NextField

            intMaxSize = tdTarget.Fields(arrTargetFields(i)).Size

            ' Get the source value safely
            On Error Resume Next
            strValue = Nz(rsSource.Fields(i).Value, "")
            If Err.Number <> 0 Then
                Err.Clear
                strValue = ""
            End If
            On Error GoTo ErrHandler

            ' --- Log if too long ---
            If Len(strValue) > intMaxSize Then
                lngViolations = lngViolations + 1
                LogViolation db, qdf.Name, strTargetTable, _
                             arrTargetFields(i), intMaxSize, _
                             strValue, strKeyVal
            End If

NextField:
        Next i

        rsSource.MoveNext
    Loop

CleanUp:
    If Not rsSource Is Nothing Then rsSource.Close
    Set rsSource = Nothing
    Set tdTarget = Nothing

    CheckSingleAppendQuery = lngViolations
    Exit Function

ErrHandler:
    Debug.Print "Error in CheckSingleAppendQuery [" & qdf.Name & "]: " & _
                Err.Number & " - " & Err.Description
    Resume CleanUp

End Function


'==============================================================================
' ParseAppendSQL
' Parses "INSERT INTO tblTarget (F1, F2) SELECT S1, S2 FROM ..."
'==============================================================================
Private Function ParseAppendSQL( _
        strSQL As String, _
        ByRef strTargetTable As String, _
        ByRef arrTargetFields() As String, _
        ByRef arrSourceFields() As String) As Boolean

    Dim strUpper        As String
    Dim posInto         As Long
    Dim posOpenPar      As Long
    Dim posClosePar     As Long
    Dim posSelect       As Long
    Dim posFrom         As Long
    Dim strFieldBlock   As String
    Dim strSelectBlock  As String

    On Error GoTo ParseFail

    strUpper = UCase(strSQL)

    ' --- Find INSERT INTO ---
    posInto = InStr(strUpper, "INSERT INTO")
    If posInto = 0 Then GoTo ParseFail

    ' --- Find opening parenthesis for target field list ---
    posOpenPar = InStr(posInto, strSQL, "(")
    posSelect  = InStr(strUpper, "SELECT")
    If posOpenPar = 0 Or posSelect = 0 Then GoTo ParseFail

    ' --- Target table name: between "INSERT INTO" and "(" ---
    strTargetTable = Trim(Mid(strSQL, posInto + 11, posOpenPar - posInto - 11))
    strTargetTable = CleanBrackets(strTargetTable)

    ' --- Target field list: between "(" and matching ")" before SELECT ---
    posClosePar = InStr(posOpenPar, strSQL, ")")
    If posClosePar = 0 Then GoTo ParseFail

    strFieldBlock = Mid(strSQL, posOpenPar + 1, posClosePar - posOpenPar - 1)
    arrTargetFields = SplitFields(strFieldBlock)

    ' --- Source field list: between SELECT and FROM ---
    posFrom = FindFromKeyword(strUpper, posSelect)
    If posFrom = 0 Then
        Debug.Print "ParseAppendSQL: Could not find FROM in: " & Left(strSQL, 200)
        GoTo ParseFail
    End If

    strSelectBlock = Trim(Mid(strSQL, posSelect + 6, posFrom - posSelect - 6))
    arrSourceFields = SplitFields(strSelectBlock)

    ' --- Field counts must match ---
    If UBound(arrTargetFields) <> UBound(arrSourceFields) Then
        Debug.Print "ParseAppendSQL: Field count mismatch in query." & vbCrLf & _
                    "  Target fields (" & UBound(arrTargetFields) + 1 & "): " & Join(arrTargetFields, ", ") & vbCrLf & _
                    "  Source fields (" & UBound(arrSourceFields) + 1 & "): " & Join(arrSourceFields, ", ")
        GoTo ParseFail
    End If

    ParseAppendSQL = True
    Exit Function

ParseFail:
    ParseAppendSQL = False

End Function


'==============================================================================
' ExtractSelectPortion
' Rebuilds the SELECT statement from the append query SQL so we can open
' it as a recordset. Strips the INSERT INTO ... ( fields ) header and
' returns just the SELECT ... FROM ... WHERE ... part.
'==============================================================================
Private Function ExtractSelectPortion( _
        strSQL As String, _
        arrSourceFields() As String) As String

    Dim strUpper  As String
    Dim posSelect As Long

    strUpper  = UCase(strSQL)
    posSelect = InStr(strUpper, "SELECT")

    If posSelect = 0 Then
        ExtractSelectPortion = ""
        Exit Function
    End If

    ' Return everything from SELECT onwards â€” this is the full runnable query
    ExtractSelectPortion = Trim(Mid(strSQL, posSelect))

End Function


'==============================================================================
' FindFromKeyword
' Finds the position of the main FROM keyword, handling spaces, linebreaks,
' tabs, and skipping any FROM inside subqueries/parentheses.
'==============================================================================
Private Function FindFromKeyword(strUpper As String, posStart As Integer) As Long

    Dim i       As Long
    Dim depth   As Integer
    Dim c       As String

    depth = 0

    For i = posStart To Len(strUpper) - 3
        c = Mid(strUpper, i, 1)

        If c = "(" Then
            depth = depth + 1
        ElseIf c = ")" Then
            depth = depth - 1
        ElseIf depth = 0 Then
            ' Match FROM surrounded by any whitespace or start/end of string
            If Mid(strUpper, i, 4) = "FROM" Then
                ' Check the character BEFORE is not a letter/digit (word boundary)
                Dim charBefore As String
                Dim charAfter  As String
                charBefore = Mid(strUpper, i - 1, 1)
                charAfter  = Mid(strUpper, i + 4, 1)

                Dim validBefore As Boolean
                Dim validAfter  As Boolean

                validBefore = (i = 1) Or (charBefore = " ") Or _
                              (charBefore = Chr(9)) Or (charBefore = Chr(10)) Or _
                              (charBefore = Chr(13)) Or (charBefore = ")")

                validAfter  = (charAfter = " ") Or (charAfter = Chr(9)) Or _
                              (charAfter = Chr(10)) Or (charAfter = Chr(13)) Or _
                              (charAfter = "[")

                If validBefore And validAfter Then
                    FindFromKeyword = i
                    Exit Function
                End If
            End If
        End If
    Next i

    FindFromKeyword = 0

End Function



'==============================================================================
' SplitFields
' Splits a comma-separated field list, respecting brackets and parentheses.
' Cleans brackets from each field name.
'==============================================================================
Private Function SplitFields(strFields As String) As String()

    Dim arrResult()     As String
    Dim colFields       As New Collection
    Dim i               As Integer
    Dim depth           As Integer
    Dim strCurrent      As String
    Dim c               As String

    depth = 0
    strCurrent = ""

    For i = 1 To Len(strFields)
        c = Mid(strFields, i, 1)

        If c = "(" Or c = "[" Then
            depth = depth + 1
            strCurrent = strCurrent & c
        ElseIf c = ")" Or c = "]" Then
            depth = depth - 1
            strCurrent = strCurrent & c
        ElseIf c = "," And depth = 0 Then
            colFields.Add CleanFieldAlias(Trim(strCurrent))
            strCurrent = ""
        Else
            strCurrent = strCurrent & c
        End If
    Next i

    ' Add last field
    If Trim(strCurrent) <> "" Then
        colFields.Add CleanFieldAlias(Trim(strCurrent))
    End If

    ReDim arrResult(0 To colFields.Count - 1)
    For i = 1 To colFields.Count
        arrResult(i - 1) = colFields(i)
    Next i

    SplitFields = arrResult

End Function


'==============================================================================
' CleanBrackets
' Removes surrounding square brackets or backticks from a name
'==============================================================================
Private Function CleanBrackets(strName As String) As String
    strName = Trim(strName)
    If Left(strName, 1) = "[" And Right(strName, 1) = "]" Then
        strName = Mid(strName, 2, Len(strName) - 2)
    End If
    CleanBrackets = strName
End Function


'==============================================================================
' CleanFieldAlias
' For source fields, strips any alias (e.g. "SomeExpr AS Alias" -> "SomeExpr AS Alias"
' kept as-is for the recordset, but for target fields we just strip brackets.
'==============================================================================
Private Function CleanFieldAlias(strField As String) As String
    ' For target fields: just remove brackets
    ' For source expressions: keep as-is (the recordset handles them positionally)
    CleanFieldAlias = CleanBrackets(strField)
End Function


'==============================================================================
' LogViolation
' Inserts one violation record into tblFieldSizeLog
'==============================================================================
Private Sub LogViolation( _
        db As DAO.Database, _
        strQueryName As String, _
        strTargetTable As String, _
        strTargetField As String, _
        intMaxAllowed As Integer, _
        strOffendingValue As String, _
        strKeyValue As String)

    Dim strSQL As String

    strSQL = "INSERT INTO tblFieldSizeLog " & _
             "(CheckDate, SourceQuery, TargetTable, TargetField, " & _
             " MaxAllowed, ActualLength, OffendingValue, SourceKeyValue) " & _
             "VALUES (" & _
             "Now(), " & _
             "'" & Replace(strQueryName, "'", "''") & "', " & _
             "'" & Replace(strTargetTable, "'", "''") & "', " & _
             "'" & Replace(strTargetField, "'", "''") & "', " & _
             intMaxAllowed & ", " & _
             Len(strOffendingValue) & ", " & _
             "'" & Replace(Left(strOffendingValue, 250), "'", "''") & "', " & _
             "'" & Replace(Left(strKeyValue, 250), "'", "''") & "'" & _
             ")"

    On Error Resume Next
    db.Execute strSQL, dbFailOnError
    If Err.Number <> 0 Then
        Debug.Print "Failed to log violation: " & Err.Description
        Err.Clear
    End If
    On Error GoTo 0

End Sub

Public Sub RunDatabaseFieldSizeCheck()

    Dim lngTotal As Long

    DoCmd.Hourglass True
    lngTotal = CheckAllAppendQueries()
    DoCmd.Hourglass False

    If lngTotal = 0 Then
        MsgBox "All clear! No field size violations found across any append queries.", _
               vbInformation, "Field Size Check Complete"
    Else
        MsgBox lngTotal & " violation(s) found across all append queries." & vbCrLf & vbCrLf & _
               "Open tblFieldSizeLog to see the full breakdown.", _
               vbExclamation, "Field Size Violations Found"
        DoCmd.OpenTable "tblFieldSizeLog", acViewNormal
    End If

End Sub

Attribute VB_Name = "modFieldSizeCheck"
Option Compare Database
Option Explicit

' ============================================================
'  CheckAppendQueryFieldSizes
'  Scans all append queries in the current database and logs
'  any records where a text value exceeds the target field's
'  maximum length into tblFieldSizeLog.
'
'  Log table (auto-created if missing): tblFieldSizeLog
'    CheckDate      - Date/Time
'    SourceQuery    - Text(100)
'    TargetTable    - Text(100)
'    TargetField    - Text(100)
'    MaxAllowed     - Long Integer
'    ActualLength   - Long Integer
'    OffendingValue - Memo / Long Text
'    SourceKeyValue - Text(255)
'
'  Returns the total number of violations found.
' ============================================================
Public Function CheckAppendQueryFieldSizes() As Long

    Dim db          As DAO.Database
    Dim qdf         As DAO.QueryDef
    Dim rsLog       As DAO.Recordset
    Dim rsSource    As DAO.Recordset
    Dim colMap      As Collection
    Dim sTarget     As String
    Dim sSelect     As String
    Dim lViolations As Long
    Dim checkDate   As Date

    checkDate = Now()
    Set db = CurrentDb()

    ' -- 1. Ensure the log table exists
    EnsureLogTable db
    Set rsLog = db.OpenRecordset("tblFieldSizeLog", dbOpenDynaset)

    ' -- 2. Loop every query in the database
    For Each qdf In db.QueryDefs

        ' Skip system / hidden queries
        If Left(qdf.Name, 1) = "~" Then GoTo NextQuery

        ' Only process append queries (dbQAppend = 64)
        If qdf.Type <> dbQAppend Then GoTo NextQuery

        ' -- 3. Extract the INSERT INTO target table name
        sTarget = ExtractTargetTable(qdf.SQL)
        If sTarget = "" Then GoTo NextQuery

        ' -- 4. Build field map: TargetField -> (srcIdx, maxSize)
        Set colMap = BuildFieldMap(db, qdf, sTarget)
        If colMap Is Nothing Then GoTo NextQuery
        If colMap.Count = 0 Then GoTo NextQuery

        ' -- 5. Open SELECT side as read-only snapshot
        '       (WHERE stripped so parameter queries still open)
        sSelect = BuildSelectSQL_NoParams(qdf.SQL)
        If sSelect = "" Then GoTo NextQuery

        On Error Resume Next
        Set rsSource = db.OpenRecordset(sSelect, dbOpenSnapshot, dbReadOnly)
        If Err.Number <> 0 Then
            Err.Clear
            On Error GoTo 0
            GoTo NextQuery
        End If
        On Error GoTo 0

        If rsSource.EOF Then
            rsSource.Close
            Set rsSource = Nothing
            GoTo NextQuery
        End If

        ' -- 6. Walk every row in the source recordset
        Dim keyFieldName As String
        keyFieldName = GetFirstFieldName(rsSource)

        rsSource.MoveFirst
        Do While Not rsSource.EOF

            Dim keyVal As String
            keyVal = SafeString(rsSource.Fields(keyFieldName).Value)

            Dim i As Integer
            For i = 1 To colMap.Count

                Dim entryV    As Variant
                entryV = colMap(i)

                If EntryMaxSize(entryV) > 0 Then

                    Dim srcVal  As String
                    Dim srcIdx  As Integer
                    srcIdx = EntrySourceIdx(entryV)

                    On Error Resume Next
                    srcVal = ""
                    srcVal = Nz(rsSource.Fields(srcIdx).Value, "")
                    On Error GoTo 0

                    Dim actualLen As Long
                    actualLen = Len(srcVal)

                    If actualLen > EntryMaxSize(entryV) Then

                        ' -- 7. Write violation to log
                        rsLog.AddNew
                            rsLog!CheckDate      = checkDate
                            rsLog!SourceQuery    = qdf.Name
                            rsLog!TargetTable    = sTarget
                            rsLog!TargetField    = EntryTarget(entryV)
                            rsLog!MaxAllowed     = EntryMaxSize(entryV)
                            rsLog!ActualLength   = actualLen
                            rsLog!OffendingValue = Left(srcVal, 1000)
                            rsLog!SourceKeyValue = keyVal
                        rsLog.Update

                        lViolations = lViolations + 1

                    End If
                End If
            Next i

            rsSource.MoveNext
        Loop

        rsSource.Close
        Set rsSource = Nothing

NextQuery:
        Set colMap   = Nothing
        Set rsSource = Nothing

    Next qdf

    rsLog.Close
    Set rsLog = Nothing
    Set db    = Nothing

    CheckAppendQueryFieldSizes = lViolations

    If lViolations = 0 Then
        MsgBox "Check complete. No field size violations found.", vbInformation
    Else
        MsgBox "Check complete. " & lViolations & _
               " violation(s) logged to tblFieldSizeLog.", vbExclamation
    End If

End Function


' ============================================================
'  DiagnoseAppendQueries
'  Prints detailed parsing info to the Immediate Window so
'  you can see exactly what the parser extracts for each
'  append query. Run this first if violations are not found.
' ============================================================
Public Sub DiagnoseAppendQueries()

    Dim db      As DAO.Database
    Dim qdf     As DAO.QueryDef
    Dim sTarget As String
    Dim sSelect As String
    Dim colMap  As Collection

    Set db = CurrentDb()

    For Each qdf In db.QueryDefs

        If Left(qdf.Name, 1) = "~" Then GoTo Skip
        If qdf.Type <> dbQAppend Then GoTo Skip

        Debug.Print "======================================="
        Debug.Print "Query : " & qdf.Name
        Debug.Print "SQL   : " & qdf.SQL
        Debug.Print "---"

        sTarget = ExtractTargetTable(qdf.SQL)
        Debug.Print "Target: [" & sTarget & "]"

        sSelect = BuildSelectSQL_NoParams(qdf.SQL)
        Debug.Print "Select: [" & sSelect & "]"

        If sTarget = "" Then
            Debug.Print "!! FAIL: Could not extract target table"
            GoTo Skip
        End If

        If sSelect = "" Then
            Debug.Print "!! FAIL: Could not extract SELECT portion"
            GoTo Skip
        End If

        Set colMap = BuildFieldMap(db, qdf, sTarget)

        If colMap Is Nothing Then
            Debug.Print "!! FAIL: BuildFieldMap returned Nothing"
        ElseIf colMap.Count = 0 Then
            Debug.Print "!! FAIL: BuildFieldMap returned 0 entries"
        Else
            Debug.Print "Mapped fields (" & colMap.Count & "):"
            Dim i As Integer
            For i = 1 To colMap.Count
                Dim v As Variant
                v = colMap(i)
                Debug.Print "  [" & i & "] Target=" & EntryTarget(v) & _
                            "  SrcIdx=" & EntrySourceIdx(v) & _
                            "  MaxSize=" & EntryMaxSize(v)
            Next i
        End If

        On Error Resume Next
        Dim rs As DAO.Recordset
        Set rs = db.OpenRecordset(sSelect, dbOpenSnapshot, dbReadOnly)
        If Err.Number <> 0 Then
            Debug.Print "!! FAIL: Could not open SELECT recordset - " & Err.Description
            Err.Clear
        ElseIf rs.EOF Then
            Debug.Print "!! NOTE: SELECT returned 0 rows"
        Else
            rs.MoveLast
            Debug.Print "Row count : " & rs.RecordCount
            rs.MoveFirst
            Dim f As DAO.Field
            Debug.Print "Columns in SELECT recordset:"
            For Each f In rs.Fields
                Debug.Print "  [" & f.OrdinalPosition & "] " & f.Name & _
                            "  Type=" & f.Type & "  Size=" & f.Size
            Next f
        End If
        On Error GoTo 0
        If Not rs Is Nothing Then rs.Close
        Set rs = Nothing

Skip:
        Set colMap = Nothing
    Next qdf

    Set db = Nothing
    Debug.Print "======================================="
    Debug.Print "Diagnosis complete. Check Immediate Window (Ctrl+G)."

End Sub


' ============================================================
'  ENTRY VARIANT ACCESSORS
'  Each map entry is a 3-element Variant array:
'    (0) = TargetFieldName  String
'    (1) = SourceFieldIndex Integer
'    (2) = MaxSize          Long
' ============================================================
Private Function NewEntry(tFld As String, srcIdx As Integer, _
                          maxSz As Long) As Variant
    Dim v(2) As Variant
    v(0) = tFld
    v(1) = srcIdx
    v(2) = maxSz
    NewEntry = v
End Function

Private Property Get EntryTarget(v As Variant) As String
    EntryTarget = CStr(v(0))
End Property

Private Property Get EntrySourceIdx(v As Variant) As Integer
    EntrySourceIdx = CInt(v(1))
End Property

Private Property Get EntryMaxSize(v As Variant) As Long
    EntryMaxSize = CLng(v(2))
End Property


' ============================================================
'  BuildFieldMap
'  Returns a Collection of Variant entries describing each
'  Text/Memo column in the INSERT field list with its
'  corresponding SELECT column index and max allowed size.
'
'  Handles both:
'    (a) Explicit field list:  INSERT INTO tbl (f1, f2) SELECT ...
'    (b) No field list:        INSERT INTO tbl SELECT ...
' ============================================================
Private Function BuildFieldMap(db As DAO.Database, _
                               qdf As DAO.QueryDef, _
                               targetTable As String) As Collection
    On Error GoTo Fail

    Dim sSQL      As String
    Dim sUpper    As String
    Dim posLP     As Long
    Dim posRP     As Long
    Dim posSelect As Long

    sSQL   = NormaliseSQL(qdf.SQL)
    sUpper = UCase(sSQL)

    ' Find the opening paren of the INSERT field list
    posLP     = InStr(1, sUpper, "(")
    posSelect = InStr(1, sUpper, "SELECT")

    ' If no paren, or paren comes AFTER SELECT -> use ordinal mapping
    If posLP = 0 Or (posSelect > 0 And posLP > posSelect) Then
        Set BuildFieldMap = BuildFieldMapByOrdinal(db, qdf, targetTable)
        Exit Function
    End If

    posRP = InStr(posLP, sSQL, ")")
    If posRP = 0 Then GoTo Fail

    Dim sInsert As String
    sInsert = Mid(sSQL, posLP + 1, posRP - posLP - 1)

    Dim insertFields() As String
    insertFields = Split(sInsert, ",")

    Dim tdf As DAO.TableDef
    Set tdf = db.TableDefs(targetTable)

    ' Open the SELECT recordset (no params) for column index mapping
    Dim sSelect As String
    sSelect = BuildSelectSQL_NoParams(sSQL)
    If sSelect = "" Then GoTo Fail

    Dim rsCheck As DAO.Recordset
    Set rsCheck = db.OpenRecordset(sSelect, dbOpenSnapshot, dbReadOnly)

    Dim col As New Collection
    Dim k   As Integer

    For k = 0 To UBound(insertFields)

        ' Clean up the field name
        Dim tFldName As String
        tFldName = Trim(Replace(Replace(insertFields(k), "[", ""), "]", ""))
        If tFldName = "" Then GoTo NextField

        ' Look up field in target table
        Dim tFld As DAO.Field
        On Error Resume Next
        Set tFld = Nothing
        Set tFld = tdf.Fields(tFldName)
        On Error GoTo 0
        If tFld Is Nothing Then GoTo NextField

        ' Only care about Text / Memo fields
        If tFld.Type <> dbText And tFld.Type <> dbMemo Then GoTo NextField

        ' The k-th INSERT field maps to the k-th SELECT column
        If k > rsCheck.Fields.Count - 1 Then GoTo NextField

        Dim maxSz As Long
        If tFld.Type = dbMemo Then
            maxSz = 65535
        Else
            maxSz = tFld.Size
        End If

        col.Add NewEntry(tFldName, k, maxSz)

NextField:
        Set tFld = Nothing
    Next k

    rsCheck.Close
    Set rsCheck = Nothing
    Set tdf     = Nothing

    Set BuildFieldMap = col
    Exit Function

Fail:
    Set BuildFieldMap = Nothing
End Function


' ============================================================
'  BuildFieldMapByOrdinal
'  Used when INSERT INTO has no explicit field list.
'  Maps SELECT columns to target table fields by position.
' ============================================================
Private Function BuildFieldMapByOrdinal(db As DAO.Database, _
                                        qdf As DAO.QueryDef, _
                                        targetTable As String) As Collection
    On Error GoTo Fail

    Dim tdf     As DAO.TableDef
    Dim sSelect As String
    Dim rsCheck As DAO.Recordset
    Dim col     As New Collection

    Set tdf = db.TableDefs(targetTable)
    sSelect = BuildSelectSQL_NoParams(NormaliseSQL(qdf.SQL))
    If sSelect = "" Then GoTo Fail

    Set rsCheck = db.OpenRecordset(sSelect, dbOpenSnapshot, dbReadOnly)

    Dim i As Integer
    For i = 0 To rsCheck.Fields.Count - 1

        If i >= tdf.Fields.Count Then Exit For

        Dim tFld As DAO.Field
        Set tFld = tdf.Fields(i)

        If tFld.Type = dbText Or tFld.Type = dbMemo Then
            Dim maxSz As Long
            If tFld.Type = dbMemo Then
                maxSz = 65535
            Else
                maxSz = tFld.Size
            End If
            col.Add NewEntry(tFld.Name, i, maxSz)
        End If

        Set tFld = Nothing
    Next i

    rsCheck.Close
    Set rsCheck = Nothing
    Set tdf     = Nothing

    Set BuildFieldMapByOrdinal = col
    Exit Function

Fail:
    Set BuildFieldMapByOrdinal = Nothing
End Function


' ============================================================
'  ExtractTargetTable
'  Parses "INSERT INTO tableName" or "INSERT INTO [tableName]"
'  Works with normalised (single-space) SQL.
' ============================================================
Private Function ExtractTargetTable(sSQL As String) As String

    Dim sNorm   As String
    Dim sUpper  As String
    Dim posInto As Long
    Dim rest    As String

    sNorm  = NormaliseSQL(sSQL)
    sUpper = UCase(sNorm)

    posInto = InStr(1, sUpper, "INSERT INTO ")
    If posInto = 0 Then
        ExtractTargetTable = ""
        Exit Function
    End If

    rest = Trim(Mid(sNorm, posInto + 12))   ' skip "INSERT INTO "

    If Left(rest, 1) = "[" Then
        Dim posClose As Long
        posClose = InStr(2, rest, "]")
        If posClose > 0 Then
            ExtractTargetTable = Mid(rest, 2, posClose - 2)
        End If
    Else
        Dim posSpace As Long
        Dim posLP    As Long
        Dim endPos   As Long
        posSpace = InStr(1, rest, " ")
        posLP    = InStr(1, rest, "(")

        If posSpace = 0 Then posSpace = Len(rest) + 1
        If posLP    = 0 Then posLP    = Len(rest) + 1
        endPos = IIf(posSpace < posLP, posSpace, posLP) - 1

        ExtractTargetTable = Left(rest, endPos)
    End If

End Function


' ============================================================
'  BuildSelectSQL
'  Returns the SELECT portion of an append query's SQL.
'  Works on normalised SQL.
' ============================================================
Private Function BuildSelectSQL(sSQL As String) As String

    Dim sNorm     As String
    Dim sUpper    As String
    Dim posSelect As Long
    Dim posRP     As Long

    sNorm  = NormaliseSQL(sSQL)
    sUpper = UCase(sNorm)

    ' Prefer finding SELECT after the closing paren of the field list
    posRP = InStr(1, sUpper, ")")
    If posRP > 0 Then
        posSelect = InStr(posRP, sUpper, "SELECT")
    End If

    ' Fall back: find SELECT after INSERT INTO
    If posSelect = 0 Then
        Dim posInto As Long
        posInto = InStr(1, sUpper, "INSERT INTO")
        If posInto > 0 Then
            posSelect = InStr(posInto, sUpper, "SELECT")
        End If
    End If

    If posSelect = 0 Then
        BuildSelectSQL = ""
    Else
        BuildSelectSQL = Trim(Mid(sNorm, posSelect))
    End If

End Function


' ============================================================
'  BuildSelectSQL_NoParams
'  Same as BuildSelectSQL but strips the WHERE clause so that
'  queries referencing form controls or parameters can still
'  be opened as a recordset (returning ALL rows).
' ============================================================
Private Function BuildSelectSQL_NoParams(sSQL As String) As String

    Dim sSelect  As String
    Dim sUpper   As String
    Dim posWhere As Long

    sSelect = BuildSelectSQL(sSQL)
    If sSelect = "" Then
        BuildSelectSQL_NoParams = ""
        Exit Function
    End If

    sUpper   = UCase(sSelect)
    posWhere = InStr(1, sUpper, " WHERE ")

    If posWhere > 0 Then

        ' Preserve GROUP BY / ORDER BY / HAVING that follow WHERE
        Dim posGroup  As Long
        Dim posOrder  As Long
        Dim posHaving As Long
        Dim posAfter  As Long

        posGroup  = InStr(posWhere, sUpper, " GROUP BY ")
        posOrder  = InStr(posWhere, sUpper, " ORDER BY ")
        posHaving = InStr(posWhere, sUpper, " HAVING ")

        posAfter = 0
        If posGroup  > 0 And (posAfter = 0 Or posGroup  < posAfter) Then posAfter = posGroup
        If posOrder  > 0 And (posAfter = 0 Or posOrder  < posAfter) Then posAfter = posOrder
        If posHaving > 0 And (posAfter = 0 Or posHaving < posAfter) Then posAfter = posHaving

        If posAfter > 0 Then
            sSelect = Left(sSelect, posWhere) & Mid(sSelect, posAfter)
        Else
            sSelect = Left(sSelect, posWhere)
        End If
    End If

    BuildSelectSQL_NoParams = sSelect

End Function


' ============================================================
'  NormaliseSQL
'  Replaces newlines and tabs with spaces, then collapses
'  multiple consecutive spaces into one. Ensures all string
'  searches work regardless of how Access stored the SQL.
' ============================================================
Private Function NormaliseSQL(sSQL As String) As String

    Dim s As String
    s = sSQL
    s = Replace(s, vbCrLf, " ")
    s = Replace(s, vbCr,   " ")
    s = Replace(s, vbLf,   " ")
    s = Replace(s, vbTab,  " ")

    Do While InStr(s, "  ") > 0
        s = Replace(s, "  ", " ")
    Loop

    NormaliseSQL = Trim(s)

End Function


' ============================================================
'  GetFirstFieldName
'  Returns name of the first field in a recordset.
'  Used as a "row key" value in the violation log.
' ============================================================
Private Function GetFirstFieldName(rs As DAO.Recordset) As String
    If rs.Fields.Count > 0 Then
        GetFirstFieldName = rs.Fields(0).Name
    Else
        GetFirstFieldName = ""
    End If
End Function


' ============================================================
'  SafeString  -  Null / Empty safe converter
' ============================================================
Private Function SafeString(v As Variant) As String
    If IsNull(v) Or IsEmpty(v) Then
        SafeString = "(null)"
    Else
        SafeString = CStr(v)
    End If
End Function


' ============================================================
'  EnsureLogTable
'  Creates tblFieldSizeLog if it does not already exist.
' ============================================================
Private Sub EnsureLogTable(db As DAO.Database)

    Const TBL As String = "tblFieldSizeLog"

    Dim tdf As DAO.TableDef
    On Error Resume Next
    Set tdf = db.TableDefs(TBL)
    On Error GoTo 0
    If Not tdf Is Nothing Then Exit Sub     ' already exists

    Set tdf = db.CreateTableDef(TBL)

    Dim fld As DAO.Field

    Set fld = tdf.CreateField("CheckDate", dbDate)
    tdf.Fields.Append fld

    Set fld = tdf.CreateField("SourceQuery", dbText, 100)
    tdf.Fields.Append fld

    Set fld = tdf.CreateField("TargetTable", dbText, 100)
    tdf.Fields.Append fld

    Set fld = tdf.CreateField("TargetField", dbText, 100)
    tdf.Fields.Append fld

    Set fld = tdf.CreateField("MaxAllowed", dbLong)
    tdf.Fields.Append fld

    Set fld = tdf.CreateField("ActualLength", dbLong)
    tdf.Fields.Append fld

    Set fld = tdf.CreateField("OffendingValue", dbMemo)
    tdf.Fields.Append fld

    Set fld = tdf.CreateField("SourceKeyValue", dbText, 255)
    tdf.Fields.Append fld

    db.TableDefs.Append tdf
    db.TableDefs.Refresh

    Set fld = Nothing
    Set tdf = Nothing

End Sub

Option Compare Database
Option Explicit

' ============================================================
'  CheckAppendQueryFieldSizes
'  Scans all append queries in the current database and logs
'  any records where a text value exceeds the target field's
'  maximum length into tblFieldSizeLog.
'
'  Requires table: tblFieldSizeLog  (auto-created if missing)
'    CheckDate      - Date/Time
'    SourceQuery    - Text(100)
'    TargetTable    - Text(100)
'    TargetField    - Text(100)
'    MaxAllowed     - Long Integer
'    ActualLength   - Long Integer
'    OffendingValue - Memo / Long Text
'    SourceKeyValue - Text(255)
' ============================================================
Public Function CheckAppendQueryFieldSizes() As Long

    Dim db          As DAO.Database
    Dim qdf         As DAO.QueryDef
    Dim tdf         As DAO.TableDef
    Dim fld         As DAO.Field
    Dim rsLog       As DAO.Recordset
    Dim rsSource    As DAO.Recordset

    Dim sSQL        As String
    Dim sTarget     As String       ' target table name
    Dim lViolations As Long
    Dim checkDate   As Date

    checkDate = Now()

    Set db = CurrentDb()

    ' ── 1. Ensure the log table exists ──────────────────────
    EnsureLogTable db

    Set rsLog = db.OpenRecordset("tblFieldSizeLog", dbOpenDynaset)

    ' ── 2. Loop every query in the database ─────────────────
    For Each qdf In db.QueryDefs

        ' Skip system / hidden queries
        If Left(qdf.Name, 1) = "~" Then GoTo NextQuery

        ' Only process append queries (dbQAppend = 64)
        If qdf.Type <> dbQAppend Then GoTo NextQuery

        sSQL = qdf.SQL

        ' ── 3. Extract the INSERT INTO target table name ────
        sTarget = ExtractTargetTable(sSQL)
        If sTarget = "" Then GoTo NextQuery

        ' ── 4. Build a map of  TargetField -> (sourceField, maxSize)
        '        by comparing INSERT field list with TableDef ──
        Dim colMap As Collection
        Set colMap = BuildFieldMap(db, qdf, sTarget)
        If colMap Is Nothing Then GoTo NextQuery
        If colMap.Count = 0 Then GoTo NextQuery

        ' ── 5. Open the SELECT side of the append query as a
        '        read-only snapshot (safe – no data is appended) ─
        Dim sSelect As String
        sSelect = BuildSelectSQL(sSQL)
        If sSelect = "" Then GoTo NextQuery

        On Error Resume Next
        Set rsSource = db.OpenRecordset(sSelect, dbOpenSnapshot, dbReadOnly)
        If Err.Number <> 0 Then
            Err.Clear
            On Error GoTo 0
            GoTo NextQuery
        End If
        On Error GoTo 0

        If rsSource.EOF Then
            rsSource.Close
            GoTo NextQuery
        End If

        ' ── 6. Walk every row in the source recordset ───────
        Dim keyFieldName As String
        keyFieldName = GetFirstFieldName(rsSource)

        rsSource.MoveFirst
        Do While Not rsSource.EOF

            Dim keyVal As String
            keyVal = SafeString(rsSource.Fields(keyFieldName).Value)

            ' Check each mapped field
            Dim i As Integer
            For i = 1 To colMap.Count

                Dim entryV     As Variant
                entryV = colMap(i)

                ' Only check Text / Memo fields with a size cap
                If EntryMaxSize(entryV) > 0 Then

                    Dim srcVal As String
                    On Error Resume Next
                    srcVal = ""
                    srcVal = Nz(rsSource.Fields(EntrySourceIdx(entryV)).Value, "")
                    On Error GoTo 0

                    Dim actualLen As Long
                    actualLen = Len(srcVal)

                    If actualLen > EntryMaxSize(entryV) Then

                        ' ── 7. Write violation to log ───────
                        rsLog.AddNew
                            rsLog!CheckDate      = checkDate
                            rsLog!SourceQuery    = qdf.Name
                            rsLog!TargetTable    = sTarget
                            rsLog!TargetField    = EntryTarget(entryV)
                            rsLog!MaxAllowed     = EntryMaxSize(entryV)
                            rsLog!ActualLength   = actualLen
                            rsLog!OffendingValue = Left(srcVal, 1000)
                            rsLog!SourceKeyValue = keyVal
                    rsLog.Update

                    lViolations = lViolations + 1

                End If
            End If
            Next i

            rsSource.MoveNext
        Loop

        rsSource.Close

NextQuery:
        ' clean up per-query objects
        Set colMap = Nothing
        Set rsSource = Nothing

    Next qdf

    rsLog.Close

    Set rsLog    = Nothing
    Set db       = Nothing

    CheckAppendQueryFieldSizes = lViolations

    If lViolations = 0 Then
        MsgBox "Check complete. No field size violations found.", vbInformation
    Else
        MsgBox "Check complete. " & lViolations & " violation(s) logged to tblFieldSizeLog.", vbExclamation
    End If

End Function


' ============================================================
'  Helper class substitute – we use a simple Type stored in a
'  Collection of objects.  Because VBA Collections store
'  Objects or Variants we wrap the Type in a lightweight class.
'  To avoid requiring a class module we use a small helper
'  that packs the data into a Variant array instead.
' ============================================================
' Pack: Array(targetFieldName, sourceFieldIndex, maxSize)
Private Function NewEntry(tFld As String, srcIdx As Integer, _
                          maxSz As Long) As Variant
    Dim v(2) As Variant
    v(0) = tFld
    v(1) = srcIdx
    v(2) = maxSz
    NewEntry = v
End Function

' Thin accessors so call-sites stay readable
Private Property Get EntryTarget(v As Variant) As String
    EntryTarget = v(0)
End Property
Private Property Get EntrySourceIdx(v As Variant) As Integer
    EntrySourceIdx = CInt(v(1))
End Property
Private Property Get EntryMaxSize(v As Variant) As Long
    EntryMaxSize = CLng(v(2))
End Property


' ============================================================
'  BuildFieldMap
'  Returns a Collection of Variant entries (see NewEntry above)
'  describing each Text/Memo column that appears in the INSERT
'  field list and has a defined MaxSize > 0.
' ============================================================
Private Function BuildFieldMap(db As DAO.Database, _
                               qdf As DAO.QueryDef, _
                               targetTable As String) As Collection

    On Error GoTo Fail

    Dim col     As New Collection
    Dim tdf     As DAO.TableDef
    Dim sSQL    As String
    Dim sInsert As String   ' the "field1, field2, …" part of INSERT INTO

    sSQL = qdf.SQL

    ' ── Extract the parenthesised INSERT field list ──────────
    '    INSERT INTO tbl (f1,f2,f3) SELECT …
    Dim posLP As Long, posRP As Long
    posLP = InStr(1, sSQL, "(", vbTextCompare)
    ' Make sure the "(" is before SELECT, not inside it
    Dim posSelect As Long
    posSelect = InStr(1, UCase(sSQL), " SELECT ")
    If posSelect = 0 Then posSelect = InStr(1, UCase(sSQL), "SELECT ")

    If posLP = 0 Or posLP > posSelect Then
        ' No explicit field list – the query relies on column order.
        ' Map by ordinal position.
        Set BuildFieldMap = BuildFieldMapByOrdinal(db, qdf, targetTable)
        Exit Function
    End If

    posRP = InStr(posLP, sSQL, ")", vbTextCompare)
    If posRP = 0 Then GoTo Fail

    sInsert = Mid(sSQL, posLP + 1, posRP - posLP - 1)

    ' Split the insert field list
    Dim insertFields() As String
    insertFields = Split(sInsert, ",")

    ' Get the target TableDef so we can look up MaxSize
    Set tdf = db.TableDefs(targetTable)

    ' Open the SELECT part as a recordset so we can map field names
    Dim sSelect As String
    sSelect = BuildSelectSQL(sSQL)
    If sSelect = "" Then GoTo Fail

    Dim rsCheck As DAO.Recordset
    Set rsCheck = db.OpenRecordset(sSelect, dbOpenSnapshot, dbReadOnly)

    Dim k As Integer
    For k = 0 To UBound(insertFields)

        Dim tFldName As String
        tFldName = Trim(Replace(Replace(insertFields(k), "[", ""), "]", ""))

        ' Look up this field in the target table
        Dim tFld As DAO.Field
        On Error Resume Next
        Set tFld = tdf.Fields(tFldName)
        On Error GoTo 0
        If tFld Is Nothing Then GoTo NextField

        ' Only care about Text fields with a meaningful size
        If tFld.Type <> dbText And tFld.Type <> dbMemo Then GoTo NextField

        Dim maxSz As Long
        If tFld.Type = dbMemo Then
            maxSz = 65535   ' practical Memo cap for checking
        Else
            maxSz = tFld.Size
        End If

        ' Find the corresponding column index in the SELECT recordset
        ' The k-th INSERT field maps to the k-th SELECT column.
        Dim srcIdx As Integer
        If k <= rsCheck.Fields.Count - 1 Then
            srcIdx = k
            col.Add NewEntry(tFldName, srcIdx, maxSz)
        End If

NextField:
        Set tFld = Nothing
    Next k

    rsCheck.Close
    Set rsCheck = Nothing
    Set tdf = Nothing

    Set BuildFieldMap = col
    Exit Function

Fail:
    Set BuildFieldMap = Nothing
End Function


' ============================================================
'  BuildFieldMapByOrdinal
'  Used when the INSERT INTO has no explicit field list.
'  Maps SELECT columns to target table fields by position.
' ============================================================
Private Function BuildFieldMapByOrdinal(db As DAO.Database, _
                                        qdf As DAO.QueryDef, _
                                        targetTable As String) As Collection
    On Error GoTo Fail

    Dim col     As New Collection
    Dim tdf     As DAO.TableDef
    Dim sSelect As String

    Set tdf = db.TableDefs(targetTable)
    sSelect = BuildSelectSQL(qdf.SQL)
    If sSelect = "" Then GoTo Fail

    Dim rsCheck As DAO.Recordset
    Set rsCheck = db.OpenRecordset(sSelect, dbOpenSnapshot, dbReadOnly)

    Dim i As Integer
    For i = 0 To rsCheck.Fields.Count - 1

        If i >= tdf.Fields.Count Then Exit For

        Dim tFld As DAO.Field
        Set tFld = tdf.Fields(i)

        If tFld.Type = dbText Or tFld.Type = dbMemo Then
            Dim maxSz As Long
            If tFld.Type = dbMemo Then
                maxSz = 65535
            Else
                maxSz = tFld.Size
            End If
            col.Add NewEntry(tFld.Name, i, maxSz)
        End If

        Set tFld = Nothing
    Next i

    rsCheck.Close
    Set rsCheck = Nothing
    Set tdf = Nothing

    Set BuildFieldMapByOrdinal = col
    Exit Function

Fail:
    Set BuildFieldMapByOrdinal = Nothing
End Function


' ============================================================
'  ExtractTargetTable
'  Parses "INSERT INTO tableName" or "INSERT INTO [tableName]"
' ============================================================
Private Function ExtractTargetTable(sSQL As String) As String

    Dim sUpper  As String
    Dim posInto As Long
    Dim rest    As String
    Dim parts() As String

    sUpper  = UCase(sSQL)
    posInto = InStr(1, sUpper, "INSERT INTO ")
    If posInto = 0 Then
        ExtractTargetTable = ""
        Exit Function
    End If

    rest = Trim(Mid(sSQL, posInto + 12))   ' skip "INSERT INTO "

    ' rest now starts with the table name (possibly bracketed)
    If Left(rest, 1) = "[" Then
        Dim posClose As Long
        posClose = InStr(2, rest, "]")
        If posClose > 0 Then
            ExtractTargetTable = Mid(rest, 2, posClose - 2)
        End If
    Else
        ' Table name ends at first space or "("
        Dim posSpace As Long, posLP As Long
        posSpace = InStr(1, rest, " ")
        posLP    = InStr(1, rest, "(")

        Dim endPos As Long
        If posSpace = 0 Then posSpace = Len(rest) + 1
        If posLP    = 0 Then posLP    = Len(rest) + 1
        endPos = IIf(posSpace < posLP, posSpace, posLP) - 1

        ExtractTargetTable = Left(rest, endPos)
    End If

End Function


' ============================================================
'  BuildSelectSQL
'  Strips the INSERT INTO … part and returns only the SELECT.
' ============================================================
Private Function BuildSelectSQL(sSQL As String) As String

    Dim posSelect As Long
    posSelect = InStr(1, UCase(sSQL), " SELECT ")
    If posSelect = 0 Then
        posSelect = InStr(1, UCase(sSQL), vbCrLf & "SELECT ")
    End If
    If posSelect = 0 Then
        posSelect = InStr(1, UCase(sSQL), "SELECT ")
    End If

    If posSelect = 0 Then
        BuildSelectSQL = ""
    Else
        BuildSelectSQL = Trim(Mid(sSQL, posSelect))
    End If

End Function


' ============================================================
'  GetFirstFieldName  – used as a "key" value in the log
' ============================================================
Private Function GetFirstFieldName(rs As DAO.Recordset) As String
    If rs.Fields.Count > 0 Then
        GetFirstFieldName = rs.Fields(0).Name
    Else
        GetFirstFieldName = ""
    End If
End Function


' ============================================================
'  SafeString  – Null-safe converter
' ============================================================
Private Function SafeString(v As Variant) As String
    If IsNull(v) Or IsEmpty(v) Then
        SafeString = "(null)"
    Else
        SafeString = CStr(v)
    End If
End Function


' ============================================================
'  EnsureLogTable
'  Creates tblFieldSizeLog if it does not already exist.
' ============================================================
Private Sub EnsureLogTable(db As DAO.Database)

    Const TBL As String = "tblFieldSizeLog"

    ' Check if already exists
    Dim tdf As DAO.TableDef
    On Error Resume Next
    Set tdf = db.TableDefs(TBL)
    On Error GoTo 0

    If Not tdf Is Nothing Then Exit Sub   ' already there

    Set tdf = db.CreateTableDef(TBL)

    Dim fld As DAO.Field

    ' CheckDate
    Set fld = tdf.CreateField("CheckDate", dbDate)
    tdf.Fields.Append fld

    ' SourceQuery
    Set fld = tdf.CreateField("SourceQuery", dbText, 100)
    tdf.Fields.Append fld

    ' TargetTable
    Set fld = tdf.CreateField("TargetTable", dbText, 100)
    tdf.Fields.Append fld

    ' TargetField
    Set fld = tdf.CreateField("TargetField", dbText, 100)
    tdf.Fields.Append fld

    ' MaxAllowed
    Set fld = tdf.CreateField("MaxAllowed", dbLong)
    tdf.Fields.Append fld

    ' ActualLength
    Set fld = tdf.CreateField("ActualLength", dbLong)
    tdf.Fields.Append fld

    ' OffendingValue  (Memo for long values)
    Set fld = tdf.CreateField("OffendingValue", dbMemo)
    tdf.Fields.Append fld

    ' SourceKeyValue
    Set fld = tdf.CreateField("SourceKeyValue", dbText, 255)
    tdf.Fields.Append fld

    db.TableDefs.Append tdf
    db.TableDefs.Refresh

    Set fld = Nothing
    Set tdf = Nothing

End Sub

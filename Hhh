Sub CheckActualDataLengths_Robust()
    Dim db As DAO.Database
    Dim qdf As DAO.QueryDef
    Dim fld As DAO.Field
    Dim targetTable As String
    Dim sourceTable As String
    Dim sourceFieldName As String
    Dim maxDataLen As Long
    Dim targetSize As Long
    Dim sqlMax As String
    Dim rsMax As DAO.Recordset
    
    Set db = CurrentDb
    
    For Each qdf In db.QueryDefs
        ' Typ 64 = Anfügeabfrage
        If qdf.Type = 64 Then
            targetTable = GetTargetTable(qdf.SQL) ' Ziel bleibt meist gleich extrahierbar
            
            Debug.Print "--- Prüfe Abfrage: " & qdf.Name & " (Ziel: " & targetTable & ") ---"
            
            For Each fld In qdf.Fields
                ' Herkunft des Feldes direkt aus den Metadaten der Query beziehen
                sourceTable = fld.SourceTable
                sourceFieldName = fld.SourceField
                
                ' Nur prüfen, wenn Feld aus einer echten Tabelle stammt und Ziel bekannt ist
                If sourceTable <> "" And targetTable <> "" Then
                    On Error Resume Next
                    ' Größe in der Zieltabelle auslesen
                    targetSize = db.TableDefs(targetTable).Fields(fld.Name).Size
                    
                    If Err.Number = 0 Then
                        ' Wir bauen eine Mini-Abfrage für genau dieses Feld
                        sqlMax = "SELECT Max(Len([" & sourceFieldName & "])) FROM [" & sourceTable & "]"
                        Set rsMax = db.OpenRecordset(sqlMax, dbOpenForwardOnly)
                        
                        maxDataLen = Nz(rsMax(0), 0)
                        rsMax.Close
                        
                        If maxDataLen > targetSize Then
                            Debug.Print "  !! ALARM: [" & fld.Name & "] Daten zu lang! Ist: " & maxDataLen & " | Erlaubt: " & targetSize
                        Else
                            Debug.Print "  OK: [" & fld.Name & "] (Max: " & maxDataLen & ")"
                        End If
                    End If
                    On Error GoTo 0
                End If
            Next fld
        End If
    Next qdf
    
    MsgBox "Prüfung beendet. Siehe Direktfenster (Strg+G).", vbInformation
End Sub

Sub ImportExcelWithSafeTypes()
    Dim fd As Office.FileDialog
    Dim strPath As String, strTempPath As String
    Dim xlApp As Object, xlWb As Object, xlWs As Object
    Dim i As Integer, lastCol As Integer
    Dim strTable As String
    
    strTable = "DeineZielTabelle" ' Name der Tabelle in Access

    ' 1. Datei auswählen
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    If fd.Show = True Then
        strPath = fd.SelectedItems(1)
    Else
        Exit Sub
    End If

    ' 2. Sicherheitskopie erstellen, um Original nicht zu verändern
    strTempPath = Environ("TEMP") & "\import_tmp.xlsx"
    If Dir(strTempPath) <> "" Then Kill strTempPath
    FileCopy strPath, strTempPath

    ' 3. Excel manipulieren
    Set xlApp = CreateObject("Excel.Application")
    Set xlWb = xlApp.Workbooks.Open(strTempPath)
    Set xlWs = xlWb.Sheets(1)

    ' Alte Header-Zeile (Zeile 1) löschen
    xlWs.Rows(1).Delete
    
    ' Neue Dummy-Zeile ganz oben einfügen (jetzt Zeile 1)
    xlWs.Rows(1).Insert
    
    ' Ermitteln, wie viele Spalten Daten haben
    lastCol = xlWs.UsedRange.Columns.Count
    
    ' Jede Zelle in der ersten Zeile mit Text füllen, um "Text-Typ" zu erzwingen
    For i = 1 To lastCol
        xlWs.Cells(1, i).Value = "TXT_DUMMY"
    Next i

    xlWb.Close SaveChanges:=True
    xlApp.Quit

    ' 4. Import nach Access (HasFieldNames:=False erzeugt Feld1, Feld2...)
    DoCmd.TransferSpreadsheet _
        TransferType:=acImport, _
        SpreadsheetType:=acSpreadsheetTypeExcel12Xml, _
        TableName:=strTable, _
        FileName:=strTempPath, _
        HasFieldNames:=False

    ' 5. Die Dummy-Zeile aus der Access-Tabelle wieder löschen
    ' Wir löschen den Datensatz, bei dem Feld1 unser "TXT_DUMMY" ist
    CurrentDb.Execute "DELETE FROM [" & strTable & "] WHERE [Feld1] = 'TXT_DUMMY';", dbFailOnError

    MsgBox "Import erfolgreich! Alle Spalten wurden als Text behandelt.", vbInformation

    ' Cleanup
    Set xlWs = Nothing: Set xlWb = Nothing: Set xlApp = Nothing
    If Dir(strTempPath) <> "" Then Kill strTempPath
End Sub


Sub CheckActualDataLengths()
    Dim db As DAO.Database
    Dim qdf As DAO.QueryDef
    Dim rsSource As DAO.Recordset
    Dim targetTable As String
    Dim sourceTable As String
    Dim fld As DAO.Field
    Dim maxDataLen As Long
    Dim targetSize As Long
    
    Set db = CurrentDb
    
    For Each qdf In db.QueryDefs
        ' Nur Anfügeabfragen
        If qdf.Type = 64 Then
            targetTable = GetTargetTable(qdf.SQL)
            ' Wir versuchen die Quelltabelle aus dem SELECT-Teil zu fischen
            sourceTable = GetSourceTable(qdf.SQL)
            
            If targetTable <> "" And sourceTable <> "" Then
                Debug.Print "--- Prüfe Daten von [" & sourceTable & "] nach [" & targetTable & "] ---"
                
                For Each fld In qdf.Fields
                    ' Prüfe nur Textfelder in der Zieltabelle
                    On Error Resume Next
                    targetSize = db.TableDefs(targetTable).Fields(fld.Name).Size
                    If Err.Number = 0 Then
                        ' Berechne die maximale Länge des Inhalts in der QUELLE
                        ' Wir nutzen DMax und Len, um den größten Wert zu finden
                        maxDataLen = Nz(db.OpenRecordset("SELECT Max(Len([" & fld.SourceField & "])) FROM [" & sourceTable & "]").Fields(0), 0)
                        
                        If maxDataLen > targetSize Then
                            Debug.Print "!! KRITISCH: Feld [" & fld.Name & "] enthält Daten mit Länge " & maxDataLen & " (Ziel erlaubt nur " & targetSize & ")"
                        Else
                            Debug.Print "OK: [" & fld.Name & "] Max Datenlänge: " & maxDataLen & " / Kapazität: " & targetSize
                        End If
                    End If
                    On Error GoTo 0
                Next fld
            End If
        End If
    Next qdf
    MsgBox "Datenprüfung abgeschlossen!", vbInformation
End Sub

' Hilfsfunktion um die Quelltabelle zu finden (vereinfacht)
Function GetSourceTable(sql As String) As String
    Dim posFrom As Long
    Dim temp As String
    posFrom = InStr(1, sql, " FROM ", vbTextCompare)
    If posFrom > 0 Then
        temp = Mid(sql, posFrom + 6)
        ' Schneidet zusätzliche Klauseln wie WHERE oder GROUP BY ab
        If InStr(temp, " ") > 0 Then temp = Left(temp, InStr(temp, " ") - 1)
        GetSourceTable = Replace(Replace(temp, "[", ""), "]", "")
    End If
End Function
